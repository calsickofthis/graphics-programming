<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Jakub Szkup lab5</title>
    <script src="https://threejs.org/build/three.js"></script>
</head>

<body>
    <script type="text/javascript">
        class Tetrahedron {
            constructor(scene) {
                const geometry = new THREE.TetrahedronGeometry(5, 0);
                const material = new THREE.MeshLambertMaterial({ color: 0xFfff00 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.velocity = new THREE.Vector3(0.5, 0.1, 0.2); //Speed
                this.acceleration = new THREE.Vector3(0, -0.003, 0);//Gravity
                this.colorChangeSpeed = 0.05; //the speed at what the color changes

                // Create wireframe that is on top of the mesh lambert
                this.wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                this.wireframe = new THREE.LineSegments(new THREE.WireframeGeometry(geometry), this.wireframeMaterial);
                this.wireframe.position.set(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z);
                scene.add(this.wireframe); //add to the scene
            }

            animate() {
                //get tetrahedron to bounce off the plane & update the position
                this.mesh.position.add(this.velocity);
                this.velocity.add(this.acceleration);

                // Check for collisions with the left and right walls on the X-axis
                if (Math.abs(this.mesh.position.x) > 10) {
                    this.velocity.x *= -1; // Reverse X
                    this.mesh.position.x = Math.sign(this.mesh.position.x) * 10;
                    this.velocity.multiplyScalar(0.9);
                }

                //check for collision with the y axis
                if (this.mesh.position.y < -5) {
                    this.mesh.position.y = -5;
                    this.velocity.y *= -1;
                    this.velocity.multiplyScalar(0.9);
                }
                // Check for collisions with the front and back walls on the Z-axis
                if (Math.abs(this.mesh.position.z) > 10) {
                    this.velocity.z *= -1; //Reverse Z
                    this.mesh.position.z = Math.sign(this.mesh.position.z) * 10;
                    this.velocity.multiplyScalar(0.9);
                }

                //update the color
                // this.material.color.r += this.colorChangeSpeed;
                // this.material.color.g += this.colorChangeSpeed;
                // this.material.color.b += this.colorChangeSpeed;

                //this.wireframe.material.color.r += this.colorChangeSpeed;
                //this.wireframe.material.color.g += this.colorChangeSpeed;
                //this.wireframe.material.color.b += this.colorChangeSpeed;

                //update position of the wireframe
                this.wireframe.position.copy(this.mesh.position);

                //rotations
                this.mesh.rotation.x += 0.01;
                this.mesh.rotation.y += 0.01;

                this.wireframe.rotation.x += 0.01;
                this.wireframe.rotation.y += 0.01;
            }

        }

        //Creating the scene
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        //WebGLRenderer
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        //Creating instance of tetrahedron
        var tetrahedron = new Tetrahedron(scene);

        // Creating the Plane
        var planeGeometry = new THREE.PlaneGeometry(20, 20);
        var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xdddddd });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -10;
        plane.receiveShadow = true;
        scene.add(plane);


        //Creating the Lights
        var spotLight = new THREE.SpotLight(0xffffff, 2);
        spotLight.position.set(15, 40, 35);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        scene.add(spotLight);

        //Creating directional light
        var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        //adding camera helper
        var shadowCameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
        scene.add(shadowCameraHelper);

        // Creating Ambient light
        var ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        //  Creating SpotLight helper
        var spotLightHelper = new THREE.SpotLightHelper(spotLight);
        scene.add(spotLightHelper);

        function animate() {
            requestAnimationFrame(animate);
            tetrahedron.animate();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>